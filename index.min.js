class t{static parse(t,e,s=(t=>t)){const r=Object.create(null);r.options=e||{},r.reviver=s,r.value="",r.entry=[],r.output=[],r.col=1,r.row=1;const a=RegExp(/"|,|\r\n|\n|\r|[^",\r\n]+/y);let n=[],i="",c=0;for(;null!==(n=a.exec(t));)switch(i=n[0],c){case 0:switch(!0){case'"'===i:c=3;break;case","===i:c=0,this.valueEnd(r);break;case/^(\r\n|\n|\r)$/.test(i):c=0,this.valueEnd(r),this.entryEnd(r);break;default:r.value+=i,c=2}break;case 2:switch(!0){case","===i:c=0,this.valueEnd(r);break;case/^(\r\n|\n|\r)$/.test(i):c=0,this.valueEnd(r),this.entryEnd(r);break;default:throw c=4,Error(`CSVError: Illegal state [row:${r.row}, col:${r.col}]`)}break;case 3:switch(!0){case'"'===i:c=4;break;default:c=3,r.value+=i}break;case 4:switch(!0){case'"'===i:c=3,r.value+=i;break;case","===i:c=0,this.valueEnd(r);break;case/^(\r\n|\n|\r)$/.test(i):c=0,this.valueEnd(r),this.entryEnd(r);break;default:throw Error(`CSVError: Illegal state [row:${r.row}, col:${r.col}]`)}}return 0!==r.entry.length&&(this.valueEnd(r),this.entryEnd(r)),r.output}static stringify(t,e={},s=(t=>t)){const r=Object.create(null);return r.options=e,r.options.eof=void 0===r.options.eof||r.options.eof,r.row=1,r.col=1,r.output="",t.forEach((e,a)=>{let n="";switch(r.col=1,e.forEach((t,a)=>{"string"==typeof t&&(t=t.replace('"','""'),t=/"|,|\r\n|\n|\r/.test(t)?`"${t}"`:t),n+=s(t,r.row,r.col),a!==e.length-1&&(n+=","),r.col++}),!0){case r.options.eof:case!r.options.eof&&a!==t.length-1:r.output+=`${n}\n`;break;default:r.output+=`${n}`}r.row++}),r.output}static valueEnd(t){const e=t.options.typed?this.inferType(t.value):t.value;t.entry.push(t.reviver(e,t.row,t.col)),t.value="",t.col++}static entryEnd(t){t.output.push(t.entry),t.entry=[],t.row++,t.col=1}static inferType(t){switch(!0){case"true"===t:case"false"===t:return"true"===t;case/.\./.test(t):return parseFloat(t);case isFinite(t):return parseInt(t);default:return t}}}class e extends HTMLElement{static get observedAttributes(){return["src","no-headers"]}attributeChangedCallback(t,e,s){this.__initialized&&e!==s&&("no-headers"===t?this.noHeaders=s:this[t]=s)}get src(){return this.getAttribute("src")}set src(t){this.setAttribute("src",t),this.setSrc(t)}get value(){return this.__data}set value(t){this.setValue(t)}get noHeaders(){return this.hasAttribute("no-headers")}set noHeaders(t){const e=this.hasAttribute("no-headers");e?this.setAttribute("no-headers",""):this.removeAttribute("no-headers"),this.setNoHeaders(e)}constructor(){super(),this.__initialized=!1,this.__headers=!0,this.__data=[],this.__table=document.createElement("table"),this.appendChild(this.__table)}async connectedCallback(){this.hasAttribute("no-headers")&&(this.__headers=!1),this.hasAttribute("src")&&this.setSrc(),this.__initialized=!0}async setSrc(){if(this.hasAttribute("src")){const e=await this.fetchSrc(this.src);this.__data=t.parse(e),this.render()}}async fetchSrc(t){const e=await fetch(t);if(200!==e.status)throw Error(`ERR ${e.status}: ${e.statusText}`);return e.text()}setValue(e){this.__data=t.parse(e),this.render()}setNoHeaders(t){this.__headers=!t,this.render()}render(){const t=[...this.__data],e=document.createElement("table");if(this.__headers){const s=t.shift(),r=document.createElement("thead"),a=document.createElement("tr");s.forEach(t=>{const e=document.createElement("th");e.innerText=t,a.appendChild(e)}),r.append(a),e.appendChild(r)}const s=document.createElement("tbody");t.forEach(t=>{const e=document.createElement("tr");t.forEach(t=>{const s=document.createElement("td");s.innerText=t,e.appendChild(s)}),s.appendChild(e)}),e.appendChild(s),this.removeChild(this.__table),this.__table=e,this.appendChild(this.__table)}}customElements.define("wc-csv-table",e);export{e as WCCSVTable};
